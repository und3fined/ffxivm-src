---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by richyczhou.
--- DateTime: 2025/6/19 20:12
---
local CommonUtil = require("Utils/CommonUtil")
local EventMgr = require("Event/EventMgr")
local EventID = require("Define/EventID")
local LuaClass = require("Core/LuaClass")
local MgrBase = require("Common/MgrBase")
local MsgTipsUtil = require("Utils/MsgTipsUtil")
local SaveKey = require("Define/SaveKey")

local LoginNewDefine = require("Game/LoginNew/LoginNewDefine")
local LoginStrID = LoginNewDefine.LoginStrID

local FLOG_INFO = _G.FLOG_INFO
local FLOG_WARNING = _G.FLOG_WARNING
local LSTR = _G.LSTR

local ULuaDelegateProxy = _G.UE.ULuaDelegateProxy
local NewObject = _G.NewObject
local UnLuaRef = _G.UnLua.Ref

---@class IOS26ResDownloadMgr : MgrBase
local IOS26ResDownloadMgr = LuaClass(MgrBase)

function IOS26ResDownloadMgr:CheckIOS26Res()
    if not self:IsIOS26() then
        -- 非IOS26系统跳过
        return
    end

    if self:CheckIOS26ResFileExist() then
        -- 文件已存在跳过
        self:MountIOS26Res()
        return
    end

    --_G.UE.USaveMgr.SetInt(SaveKey.IOS26ResTipsCount, 0, true)
    local ShowCount = _G.UE.USaveMgr.GetInt(SaveKey.IOS26ResTipsCount, 0, true) or 0
    FLOG_INFO("[IOS26ResDownloadMgr:CheckIOS26Res] ShowCount:%d ", ShowCount)
    if ShowCount >= 3 then
        -- 已经弹窗过3次跳过
        return
    end

    -- 弹窗提示是否下载IOS26资源
    local function Callback()
        self:RegisterTimer(self.TryDownload, 0.2, 0)
    end
    local function CancelCallback()
        _G.UE.USaveMgr.SetInt(SaveKey.IOS26ResTipsCount, ShowCount + 1, true)
    end
    -- 10002(确  认), 10003(取  消), 10004(提  示)
    _G.MsgBoxUtil.ShowMsgBoxTwoOp(self, LSTR("iOS 26画面异常修复提示"),
            LSTR("因升级iOS26游戏画面异常的用户，可点击“确认”修复；\n若无异常，可点击“取消”忽略。（3次忽略后不再提示）"),
            Callback, CancelCallback, LSTR(10003), LSTR(10002))
end

function IOS26ResDownloadMgr:TryDownload()
    -- 下载IOS26资源
    local CreateRet = self:InitDownloader()
    if not CreateRet then
        FLOG_WARNING("[IOS26ResDownloadMgr:TryDownload] InitDownloader failed")
        return
    end

    if CreateRet.InitStatus == _G.UE.ELaunchPufferTaskStatus.DOWNLOADED then
        -- 3
        -- 已下载
    elseif CreateRet.InitStatus == _G.UE.ELaunchPufferTaskStatus.INVALID then
        -- 2
        _G.MsgBoxUtil.ShowMsgBoxOneOpRight(nil, LSTR(LoginStrID.TipsTitle), LSTR(LoginStrID.PufferStartErr))
    elseif CreateRet.InitStatus == _G.UE.ELaunchPufferTaskStatus.PUFFER_NOT_INIT then
        -- 1
        _G.MsgBoxUtil.ShowMsgBoxOneOpRight(nil, LSTR(LoginStrID.TipsTitle), LSTR(LoginStrID.PufferInitErr))
    elseif CreateRet.InitStatus == _G.UE.ELaunchPufferTaskStatus.SUCCESS then
        -- 4
        if self.PufferDownloader and self.PufferDownloader:IsValid() then
            FLOG_INFO("[IOS26ResDownloadMgr:TryDownload] Start Download")
            --MsgTipsUtil.ShowTips(LSTR("开始下载"))
            -- 下载中
            _G.MsgBoxUtil.ShowMsgBoxOneOpRight(self, LSTR(10004), LSTR("正在下载中(9MB)，请耐心等待，下载完成后自动关闭"))

            self.PufferDownloader:TryDownloadTask()
        else
            FLOG_WARNING("[IOS26ResDownloadMgr:TryDownload] PufferDownloader is invalid")
            _G.MsgBoxUtil.ShowMsgBoxOneOpRight(nil, LSTR(LoginStrID.TipsTitle), LSTR(LoginStrID.PufferStartErr))
        end
    end
end

function IOS26ResDownloadMgr:IsIOS26()
    if not CommonUtil.IsIOSPlatform() then
        return false
    end

    local OSVersion = _G.UE.UPlatformUtil.GetOSVersion()
    print("[IOS26ResDownloadMgr:IsIOS26] - OSVersion: ", OSVersion)
    if string.isnilorempty(OSVersion) then
        return false
    end

    local SplitList = string.split(OSVersion, ".")
    if #SplitList > 0 then
        local Major = tonumber(SplitList[1] or 0)
        if Major >= 19 then
            FLOG_INFO("[IOS26ResDownloadMgr:IsIOS26] - IOS26")
            return true
        end
    end
    return false
end

function IOS26ResDownloadMgr:GetDownloadedFileList()
    local Path = _G.UE.UPufferMgr.Get():GetPufferDownloadDir(true)
    local DownloadedFileList = {
        string.format("%s/%s", Path, "ios26_fix_render_IOS_P.pak"),
        string.format("%s/%s", Path, "ios26_fix_render_sf_metal.0.metallib"),
        string.format("%s/%s", Path, "ios26_fix_render_sf_metal.metalmap")
    }
    return DownloadedFileList
end

function IOS26ResDownloadMgr:CheckIOS26ResFileExist()
    local DownloadedFileList = self:GetDownloadedFileList()
    if not DownloadedFileList or #DownloadedFileList == 0 then
        FLOG_INFO("[IOS26ResDownloadMgr:CheckIOS26ResFileExist] - DownloadedFileList is empty")
        return
    end

    local FileCnt = #DownloadedFileList
    local IsExist = true
    for i = 1, FileCnt, 1 do
        if _G.FDIR_EXISTFILE(DownloadedFileList[i]) then
            FLOG_INFO("[IOS26ResDownloadMgr:CheckIOS26ResFileExist] - Exist - Src:%s ", DownloadedFileList[i])
        else
            IsExist = false
            FLOG_INFO("[IOS26ResDownloadMgr:CheckIOS26ResFileExist] - NOT Exist - Src:%s ", DownloadedFileList[i])
        end
    end
    return IsExist
end

function IOS26ResDownloadMgr:GetIOS26ResFileList()
    -- Download files
    local DownloadFileList = {
        "ios26_fix_render_IOS_P.pak",
        "ios26_fix_render_sf_metal.0.metallib",
        "ios26_fix_render_sf_metal.metalmap"
    }
    return DownloadFileList
end

function IOS26ResDownloadMgr:InitDownloader()
    -- PufferTask
    local PufferTask = _G.UE.FPufferTask()
    PufferTask.SrcUnits = _G.UE.TArray(_G.UE.FPufferTaskUnit)
    PufferTask.bAutoDownload = false

    local DownloadFileList = self:GetIOS26ResFileList()
    if not DownloadFileList then
        FLOG_WARNING("[IOS26ResDownloadMgr:InitDownloader] DownloadFileList is nil")
        return
    end

    local FileCnt = #DownloadFileList
    for i = 1, FileCnt, 1 do
        local TaskUnit = _G.UE.FPufferTaskUnit()
        TaskUnit.Mode = _G.UE.EPufferTaskMode.Filename
        TaskUnit.Src = DownloadFileList[i]
        TaskUnit.Priority = 0
        PufferTask.SrcUnits:Add(TaskUnit)
        FLOG_INFO("[IOS26ResDownloadMgr:InitDownloader] Src:%s", TaskUnit.Src)
    end

    -- PufferDownloader
    -- 下载进度回调
    local function OnPufferTaskProgress(Delegate, Downloader, Progress)
        FLOG_INFO("[IOS26ResDownloadMgr:InitDownloader] OnPufferTaskProgress : %d/%d", Progress.nowSize, Progress.totalSize)
        --EventMgr:SendEvent(EventID.PreDownloadProgress, Progress)
        --if Progress.totalSize > 0 then
        --    local Percent = 100 * Progress.nowSize / Progress.totalSize
        --    --if Percent % 10 == 0 then
        --        MsgTipsUtil.ShowTips(string.format("%s %d%%", LSTR(LoginStrID.Downloading), Percent))
        --    --end
        --end
    end
    -- 下载完成回调
    local function OnFinished(Delegate, Downloader, Results)
        _G.MsgBoxUtil.CloseMsgBox()
        if Results.bIsSuccess then
            FLOG_INFO("[IOS26ResDownloadMgr:InitDownloader] Finished!!!")
            self:MountIOS26Res()
        else
            --下载出错
            local Cnt = Results.ErrorUnits:Length()
            local ErrorCode = 0
            for i = 1, Cnt, 1 do
                local ErrorUnit = Results.ErrorUnits:Get(i)
                ErrorCode = ErrorUnit.Result.ErrorCode
                break
            end
            FLOG_INFO("[IOS26ResDownloadMgr:InitDownloader] Failed - ErrorCode:%d", ErrorCode)
        end
        self.OnFinishDelegateRef = nil
        self.OnProgressDelegateRef = nil
        self.OnUnitFinishedDelegateRef = nil
        self.DownloadFailed = true
    end
    -- 单个文件下载完成回调
    local function OnUnitFinishedProgress(Delegate, Downloader, UnitRecord)
        if UnitRecord and UnitRecord.PufferUnit and UnitRecord.PufferUnit.Src then
            FLOG_INFO("[IOS26ResDownloadMgr:InitDownloader] OnUnitFinishedProgress - Unit finish:%s", UnitRecord.PufferUnit.Src)
        end
    end

    local OnFinishDelegateRef, OnFinishDelegate = self:GetDelegatePair(OnFinished)
    local OnProgressDelegateRef, OnProgressDelegate = self:GetDelegatePair(OnPufferTaskProgress)
    local OnUnitFinishedDelegateRef, OnUnitFinishedDelegate = self:GetDelegatePair(OnUnitFinishedProgress)
    self.OnFinishDelegateRef = OnFinishDelegateRef
    self.OnProgressDelegateRef = OnProgressDelegateRef
    self.OnUnitFinishedDelegateRef = OnUnitFinishedDelegateRef

    local CreateRet = _G.UE.UPufferMgr:Get():CreateDownloader(PufferTask, OnFinishDelegate, OnProgressDelegate, OnUnitFinishedDelegate)
    local InitStatus = CreateRet.InitStatus

    FLOG_INFO("[IOS26ResDownloadMgr:InitDownloader] InitStatus:%d", InitStatus)
    --[[
    if InitStatus == _G.UE.ELaunchPufferTaskStatus.DOWNLOADED then
        -- 3

    elseif InitStatus == _G.UE.ELaunchPufferTaskStatus.INVALID then
        -- 2
        _G.MsgBoxUtil.ShowMsgBoxOneOpRight(nil, LSTR(LoginStrID.TipsTitle), LSTR(LoginStrID.PufferStartErr))
    elseif InitStatus == _G.UE.ELaunchPufferTaskStatus.PUFFER_NOT_INIT then
        -- 1
        _G.MsgBoxUtil.ShowMsgBoxOneOpRight(nil, LSTR(LoginStrID.TipsTitle), LSTR(LoginStrID.PufferInitErr))
    elseif InitStatus == _G.UE.ELaunchPufferTaskStatus.SUCCESS then
        -- 4
        --_G.UE.USaveMgr.SetInt(SaveKey.IOS26ResDownload, 1, true)


        --local DownloadedSize = CreateRet.Downloader:GetDownloadedSize()
        local TotalSize = CreateRet.Downloader:GetTotalSizeCompressed()
        local DownloadedSize = TotalSize - CreateRet.Downloader:GetNeedDownloadSize()
        if DownloadedSize > 0 then
            local TempProgress = {}
            --TempProgress.nowSize = DownloadedSize
            --TempProgress.totalSize = DownloadedSize + CreateRet.Downloader:GetNeedDownloadSize()
            TempProgress.totalSize = TotalSize
            if TempProgress.totalSize < 0 then
                TempProgress.totalSize = 0
                FLOG_INFO("[IOS26ResDownloadMgr:InitDownloader] totalSize: %d", TotalSize)
            end
            TempProgress.nowSize = DownloadedSize
            if TempProgress.nowSize < 0 then
                TempProgress.nowSize = 0
                FLOG_INFO("[IOS26ResDownloadMgr:InitDownloader] nowSize invalid: %d/%d", TotalSize, CreateRet.Downloader:GetNeedDownloadSize())
            end
            self.DownloadProgress = TempProgress
            FLOG_INFO("[IOS26ResDownloadMgr:InitDownloaderInitDownloader] Progress %d/%d", TempProgress.nowSize, TempProgress.totalSize)

            --self.DownloadState = LoginNewDefine.PreDownloadState.Pause
            --EventMgr:SendEvent(EventID.PreDownloadState, LoginNewDefine.PreDownloadState.Pause)
        else
            --self.DownloadState = LoginNewDefine.PreDownloadState.Normal
            --EventMgr:SendEvent(EventID.PreDownloadState, LoginNewDefine.PreDownloadState.Normal)
        end
    end
    ]]--

    self.PufferDownloader = CreateRet.Downloader
    return CreateRet
end

function IOS26ResDownloadMgr:MountIOS26Res()
    local DownloadedFileList = self:GetDownloadedFileList()
    if not DownloadedFileList or #DownloadedFileList == 0 then
        FLOG_INFO("[IOS26ResDownloadMgr:MountIOS26Res] Can't found DownloadedFileList or list is empty")
        return
    end

    local FileCnt = #DownloadedFileList
    for i = 1, FileCnt, 1 do
        local MountFile = DownloadedFileList[i]
        if _G.FDIR_EXISTFILE(MountFile) then
            FLOG_INFO("[IOS26ResDownloadMgr:MountIOS26Res] Mount File:%s ", MountFile)
            _G.UE.UVersionMgr.Get():MountPak(MountFile, 200000, true, true)
        else
            FLOG_INFO("[IOS26ResDownloadMgr:MountIOS26Res] Mount failed. %s ", MountFile)
        end
    end
end

function IOS26ResDownloadMgr:GetDelegatePair(InFunc)
    if type(InFunc) ~= "function" then
        return nil
    end

    local Proxy = NewObject(ULuaDelegateProxy)
    local Ref = UnLuaRef(Proxy)

    local WrappedFunc = function(...)
        InFunc(...)
    end
    return Ref, { Proxy, WrappedFunc }
end

return IOS26ResDownloadMgr
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by richyczhou.
--- DateTime: 2024/8/14 15:44
---

local CommonUtil = require("Utils/CommonUtil")
local DataReportUtil = require("Utils/DataReportUtil")
local EventMgr = require("Event/EventMgr")
local EventID = require("Define/EventID")
local Json = require("Core/Json")
local LuaClass = require("Core/LuaClass")
local LoginNewDefine = require("Game/LoginNew/LoginNewDefine")
local MgrBase = require("Common/MgrBase")
local SaveKey = require("Define/SaveKey")
local TimerMgr = require("Timer/TimerMgr")
local TimeUtil = require("Utils/TimeUtil")
local UIViewID = require("Define/UIViewID")
local UIViewMgr = require("UI/UIViewMgr")

local FLOG_INFO = _G.FLOG_INFO
local FLOG_WARNING = _G.FLOG_WARNING
local LSTR = _G.LSTR
local UVersionMgr = _G.UE.UVersionMgr
local LoginStrID = LoginNewDefine.LoginStrID

local ULuaDelegateProxy = _G.UE.ULuaDelegateProxy
local NewObject = _G.NewObject
local UnLuaRef = _G.UnLua.Ref

local ConfigModuleName = "Config/PreDownloadConfig"


---@class PreDownloadMgr : MgrBase
local PreDownloadMgr = LuaClass(MgrBase)

function PreDownloadMgr:Ctor()
    ---@type PreDownloadConfig
    self.PreDownloadConfig = nil
    self.PreDownloadState = LoginNewDefine.PreDownloadState.Normal

    self.PufferDownloader = nil
    self.IsAlive = true
    self.CheckStartTimerId = nil
    self.RetryGetJsonCount = 0
    self.DownloadProgress = nil
    self.HasStartDownload = false
    self.bHasCheckPreDownload = false
    self.DownloadFailed = false
end

function PreDownloadMgr:OnInit()
    FLOG_INFO("PreDownloadMgr:OnInit ")
    self.IsAlive = true
end

function PreDownloadMgr:OnBegin()
    FLOG_INFO("PreDownloadMgr:OnBegin ")
end

function PreDownloadMgr:OnEnd()
    FLOG_INFO("PreDownloadMgr:OnEnd ")
end

function PreDownloadMgr:OnShutdown()
    FLOG_INFO("PreDownloadMgr:OnShutdown ")
    self.IsAlive = false
end

function PreDownloadMgr:CheckPreDownloadConfigExist()
    local ProjectDir = UE4.UKismetSystemLibrary.GetProjectDirectory()
    local PreDownloadConfigPath = string.format("%s/Source/Script/%s.lua", ProjectDir, ConfigModuleName)
    if _G.FDIR_EXISTFILE(PreDownloadConfigPath) then
        local PreDownloadConfig = require(ConfigModuleName)
        if PreDownloadConfig then
            self.PreDownloadConfig = PreDownloadConfig
            --FLOG_INFO("PreDownloadMgr:CheckPreDownloadConfigExists ")
            return true
        else
            FLOG_INFO("PreDownloadMgr:CheckPreDownloadConfigExists PreDownloadConfig load failed...")
        end
    else
        FLOG_INFO("PreDownloadMgr:CheckPreDownloadConfigExists PreDownloadConfig no exist...")
    end

    self:CancelCheckStartTimer()
    return false
end

function PreDownloadMgr:CheckDate()
    if self.PreDownloadConfig.StartTime == nil or self.PreDownloadConfig.StartTime == 0 then
        --FLOG_INFO("[PreDownloadMgr:CheckDate] StartTime CheckResult:true")
        return true
    end

    local ServerTime = TimeUtil.GetServerTime()
    local CheckResult = ServerTime >= self.PreDownloadConfig.StartTime and ServerTime < self.PreDownloadConfig.StopTime

    local ServerDate = TimeUtil.GetTimeFormat("%Y/%m/%d %H:%M:%S", ServerTime)
    local StartDate = TimeUtil.GetTimeFormat("%Y/%m/%d %H:%M:%S", self.PreDownloadConfig.StartTime)
    local EndDate = TimeUtil.GetTimeFormat("%Y/%m/%d %H:%M:%S", self.PreDownloadConfig.StopTime)
    local NewVerDate = TimeUtil.GetTimeFormat("%Y/%m/%d %H:%M:%S", self.PreDownloadConfig.NewVersionTime)
    --FLOG_INFO("[PreDownloadMgr:CheckDate] Time CheckResult: %s, ServerDate:%s, StartDate:%s, EndDate:%s, NewVerDate:%s", tostring(CheckResult), ServerDate, StartDate, EndDate, NewVerDate)
    return CheckResult
end

function PreDownloadMgr:CheckDownloadFilesExist()
    local JsonFileName = UVersionMgr.Get():GetRPDescFile(self.PreDownloadConfig.AppVersion, self.PreDownloadConfig.TargetAppVersion)
    local bExist = _G.UE.UPufferMgr:Get():IsContainInRemote(JsonFileName)
    --FLOG_INFO("[PreDownloadMgr:CheckDownloadFilesExist] Check [%s -> %s] IsContainInRemote [%s]:%s" , self.PreDownloadConfig.AppVersion, self.PreDownloadConfig.TargetAppVersion, tostring(bExist), JsonFileName)
    if not bExist then
        return
    end

    -- PufferTask
    local PufferTask = _G.UE.FPufferTask()
    PufferTask.SrcUnits = _G.UE.TArray(_G.UE.FPufferTaskUnit)
    PufferTask.bAutoDownload = true

    -- Download files
    local TaskUnit = _G.UE.FPufferTaskUnit()
    TaskUnit.Mode = _G.UE.EPufferTaskMode.Filename
    TaskUnit.Src = JsonFileName
    TaskUnit.Priority = 0
    PufferTask.SrcUnits:Add(TaskUnit)
    --FLOG_INFO("[PreDownloadMgr:CheckDownloadFilesExist] Src:%s", JsonFileName)

    -- PufferDownloader
    local function OnFinished(Delegate, Downloader, Results)
        if Results.bIsSuccess then
            FLOG_INFO("[PreDownloadMgr:CheckDownloadFilesExist] bIsSuccess")
            self:ParseJson(JsonFileName)
        else
            --下载出错
            local Cnt = Results.ErrorUnits:Length()
            local ErrorCode = 0
            for i = 1, Cnt, 1 do
                local ErrorUnit = Results.ErrorUnits:Get(i)
                ErrorCode = ErrorUnit.Result.ErrorCode
                break
            end
            FLOG_INFO("[PreDownloadMgr:CheckDownloadFilesExist] ErrorCode:%d", ErrorCode)
        end
    end
    local OnFinishDelegate = CommonUtil.GetDelegatePair(OnFinished, true)
    local CreateRet = _G.UE.UPufferMgr:Get():CreateDownloader(PufferTask, OnFinishDelegate, nil, nil)

    local InitStatus = CreateRet.InitStatus
    FLOG_INFO("[PreDownloadMgr:CheckDownloadFilesExist] InitStatus:%d", InitStatus)
    if InitStatus == _G.UE.ELaunchPufferTaskStatus.DOWNLOADED then
        self:ParseJson(JsonFileName)
    --else
    --    self.RetryGetJsonCount = self.RetryGetJsonCount + 1
    --    if self.RetryGetJsonCount > 5 then
    --        self.RetryGetJsonCount = 0
    --        self:CancelCheckStartTimer()
    --    end
    end

    self:CancelCheckStartTimer()
    return InitStatus == _G.UE.ELaunchPufferTaskStatus.SUCCESS
end

function PreDownloadMgr:CheckPreDownload()
    if not self:CheckPreDownloadConfigExist() then
        return
    end

    local LocalAppVersion = _G.UE.UVersionMgr.GetAppVersion()
    local CheckResult = LocalAppVersion == self.PreDownloadConfig.AppVersion
    FLOG_INFO("[PreDownloadMgr:CheckPreDownload] Version CheckResult: %s (%s == %s)", tostring(CheckResult), LocalAppVersion, self.PreDownloadConfig.AppVersion)
    if not CheckResult then
        FLOG_INFO("[PreDownloadMgr:CheckPreDownload] PreDownload no valid AppVersion ")
        return
    end

    local ServerTime = TimeUtil.GetServerTime()
    CheckResult = ServerTime >= self.PreDownloadConfig.StartTime and ServerTime < self.PreDownloadConfig.StopTime

    local ServerDate = TimeUtil.GetTimeFormat("%Y/%m/%d %H:%M:%S", ServerTime)
    local StartDate = TimeUtil.GetTimeFormat("%Y/%m/%d %H:%M:%S", self.PreDownloadConfig.StartTime)
    local EndDate = TimeUtil.GetTimeFormat("%Y/%m/%d %H:%M:%S", self.PreDownloadConfig.StopTime)
    FLOG_INFO("[PreDownloadMgr:CheckDate] Time CheckResult: %s, ServerDate:%s, StartDate:%s, EndDate:%s", tostring(CheckResult), ServerDate, StartDate, EndDate)

    if ServerTime > self.PreDownloadConfig.StopTime then
        FLOG_INFO("[PreDownloadMgr:CheckPreDownload] PreDownload StopTime ")
        return
    end

    -- 如果ServerTime小于开始时间则定时检查
    if not self.HasCheckStartTimer then
        self.HasCheckStartTimer = true
        self.CheckStartTimerId = self:RegisterTimer(function()
            if self.IsAlive then
                self:CheckPreDownload()
            end
        end, 30, 30, 0)
    end

    if ServerTime < self.PreDownloadConfig.StartTime then
        FLOG_INFO("[PreDownloadMgr:CheckPreDownload] PreDownload no valid time ")
        return
    end

    --CheckResult = CheckResult and self:CheckDownloadFilesExist()
    --FLOG_INFO("[PreDownloadMgr:CheckPreDownload] Check final result:%s", tostring(CheckResult))
    CheckResult = self:CheckDownloadFilesExist()
end

function PreDownloadMgr:ParseJson(JsonFileName)
    local JsonPath = string.format("%s/%s", _G.UE.UPufferMgr.Get():GetPufferDownloadDir(), JsonFileName)
    local file = io.open(JsonPath, "r")
    if not file then
        FLOG_INFO("[PreDownloadMgr:ParseJson] Can't open json file:%s", JsonPath)
        return
    end
    local content = file:read("*a") -- 读取所有内容
    file:close()

    local data = Json.decode(content)
    FLOG_INFO("[PreDownloadMgr:ParseJson] Json string:\n%s", content)

    self.DownloadedFiles = _G.UE.TArray(_G.UE.FRPFile)

    local HasPreDownloadFiles = false
    if data.platformRecord then
        self.DownloadList = {}
        if CommonUtil.IsAndroidPlatform() then
            if data.platformRecord.Android_ASTC and data.platformRecord.Android_ASTC.files then
                for _, FileItem in ipairs(data.platformRecord.Android_ASTC.files) do
                    HasPreDownloadFiles = true
                    FLOG_INFO("[PreDownloadMgr:ParseJson] +++ Add[Android_ASTC] FileName:%s, Size:%d, MD5:%s", FileItem.name, FileItem.size, FileItem.mD5)
                    table.insert(self.DownloadList, FileItem.name)

                    local File = _G.UE.FRPFile()
                    File.Filename = FileItem.name
                    File.Size = FileItem.size
                    File.MD5 = FileItem.mD5
                    self.DownloadedFiles:Add(File)
                end
            else
                FLOG_WARNING("[PreDownloadMgr:ParseJson] Android - Json invalid")
            end
        elseif CommonUtil.IsIOSPlatform() then
            if data.platformRecord.IOS and data.platformRecord.IOS.files then
                for _, FileItem in ipairs(data.platformRecord.IOS.files) do
                    HasPreDownloadFiles = true
                    FLOG_INFO("[PreDownloadMgr:ParseJson] +++ Add[IOS] FileName:%s, Size:%d, MD5:%s", FileItem.name, FileItem.size, FileItem.mD5)
                    table.insert(self.DownloadList, FileItem.name)

                    local File = _G.UE.FRPFile()
                    File.Filename = FileItem.name
                    File.Size = FileItem.size
                    File.MD5 = FileItem.mD5
                    self.DownloadedFiles:Add(File)
                end
            else
                FLOG_WARNING("[PreDownloadMgr:ParseJson] IOS - Json invalid")
            end
        else
            if data.platformRecord.Android_ASTC and data.platformRecord.Android_ASTC.files then
                for _, FileItem in ipairs(data.platformRecord.Android_ASTC.files) do
                    HasPreDownloadFiles = true
                    FLOG_INFO("[PreDownloadMgr:ParseJson] +++ Add[Android_ASTC] FileName:%s, Size:%d, MD5:%s", FileItem.name, FileItem.size, FileItem.mD5)
                    table.insert(self.DownloadList, FileItem.name)

                    local File = _G.UE.FRPFile()
                    File.Filename = FileItem.name
                    File.Size = FileItem.size
                    File.MD5 = FileItem.mD5
                    self.DownloadedFiles:Add(File)
                end
            else
                FLOG_WARNING("[PreDownloadMgr:ParseJson] Json invalid")
            end
        end
    else
        FLOG_WARNING("[PreDownloadMgr:ParseJson] platformRecord invalid...")
    end

    if HasPreDownloadFiles then
        --self.PreDownloadState = _G.UE.USaveMgr.GetInt(SaveKey.PreDownloadFlag, 0, false)
        self.PreDownloadRedClick = _G.UE.USaveMgr.GetString(SaveKey.PreDownloadRedDot, "", false)
        self.PreDownloadErrorRedDot = false
        FLOG_INFO("[PreDownloadMgr:CheckPreDownload] PreDownloadState:%d, PreDownloadRedClick:%s", self.PreDownloadState, self.PreDownloadRedClick)

        self:OnPreDownloadOpen()
    end
end

function PreDownloadMgr:CancelCheckStartTimer()
    if self.CheckStartTimerId then
        TimerMgr:CancelTimer(self.CheckStartTimerId)
        self.CheckStartTimerId = nil
    end
end

function PreDownloadMgr:OnPreDownloadOpen()
    FLOG_INFO("[PreDownloadMgr:OnPreDownloadOpen] ")

    DataReportUtil.ReportLoginFlowData(_G.UE.EDataReportLoginPhase.PreDownload)
    _G.UE.UGPMMgr.Get():PostLoginStepEvent(_G.UE.EDataReportLoginPhase.PreDownload, 0, 0, "success", "", false, false)
    self:InitDownload()

    EventMgr:SendEvent(EventID.ShowPreDownload)

    if self.CheckStopTimerId then
        TimerMgr:CancelTimer(self.CheckStopTimerId)
        self.CheckStopTimerId = nil
    end

    self.CheckStopTimerId = self:RegisterTimer(function()
        if self.IsAlive then
            local ServerTime = TimeUtil.GetServerTime()
            --local ServerDate = TimeUtil.GetTimeFormat("%Y/%m/%d %H:%M:%S", ServerTime)
            --local EndDate = TimeUtil.GetTimeFormat("%Y/%m/%d %H:%M:%S", self.PreDownloadConfig.StopTime)
            --local NewVerDate = TimeUtil.GetTimeFormat("%Y/%m/%d %H:%M:%S", self.PreDownloadConfig.NewVersionTime)
            --FLOG_INFO("[PreDownloadMgr:OnPreDownloadOpen] Check PreDownloadStop. ServerTime:%s, StopTime:%s, NewVerDate:%s", ServerDate, EndDate, NewVerDate)
            if ServerTime > self.PreDownloadConfig.StopTime then
                TimerMgr:CancelTimer(self.CheckStopTimerId)
                EventMgr:SendEvent(EventID.HidePreDownload)
                UIViewMgr:HideView(UIViewID.LoginPreDownload)
            end
        end
    end, 10, 10, 0)
end

function PreDownloadMgr:OnPufferTaskProgress(Delegate, Downloader, Progress)
    FLOG_INFO("PreDownloadMgr:StartDownload OnPufferTaskProgress : %d/%d", Progress.nowSize, Progress.totalSize)
    EventMgr:SendEvent(EventID.PreDownloadProgress, Progress)
end

function PreDownloadMgr:InitDownload()
    if self.CreateRet then
        FLOG_INFO("PreDownloadMgr:InitDownload Puffer has Start")
        return nil
    end

    self.PreDownloadState = LoginNewDefine.PreDownloadState.Init
    EventMgr:SendEvent(EventID.PreDownloadState, LoginNewDefine.PreDownloadState.Init)

    -- PufferTask
    local PufferTask = _G.UE.FPufferTask()
    PufferTask.SrcUnits = _G.UE.TArray(_G.UE.FPufferTaskUnit)
    PufferTask.bAutoDownload = false

    -- Download files
    local PreDownloadFileList = self.DownloadList
    local FileCnt = #PreDownloadFileList
    for i = 1, FileCnt, 1 do
        local TaskUnit = _G.UE.FPufferTaskUnit()
        TaskUnit.Mode = _G.UE.EPufferTaskMode.Filename
        TaskUnit.Src = PreDownloadFileList[i]
        TaskUnit.Priority = 0
        FLOG_INFO("PreDownloadMgr:InitDownload Src:%s", TaskUnit.Src)

        PufferTask.SrcUnits:Add(TaskUnit)
    end

    -- PufferDownloader
    local function OnPufferTaskProgress(Delegate, Downloader, Progress)
        --FLOG_INFO("[PreDownloadMgr:InitDownload] OnPufferTaskProgress : %d/%d", Progress.nowSize, Progress.totalSize)
        EventMgr:SendEvent(EventID.PreDownloadProgress, Progress)
    end
    local function OnFinished(Delegate, Downloader, Results)
        if Results.bIsSuccess then
            DataReportUtil.ReportLoginFlowData(_G.UE.EDataReportLoginPhase.PreDownloadFinished)
            _G.UE.UGPMMgr.Get():PostLoginStepEvent(_G.UE.EDataReportLoginPhase.PreDownloadFinished, 0, 0, "success", "", false, false)
            self.PreDownloadState = LoginNewDefine.PreDownloadState.Finish
            _G.UE.USaveMgr.SetInt(SaveKey.PreDownloadFlag, LoginNewDefine.PreDownloadState.Finish, true)
            EventMgr:SendEvent(EventID.PreDownloadState, LoginNewDefine.PreDownloadState.Finish)

            -- 验证后调用AddHierarchy和SaveRecorderToDisk
            local Hierarchy = _G.UE.FRPPatchHierarchy()
            Hierarchy.BaseVersion = self.PreDownloadConfig.AppVersion
            Hierarchy.PatchVersion = self.PreDownloadConfig.TargetAppVersion
            Hierarchy.SavedDir = _G.UE.UPufferMgr.Get():GetPufferDownloadDir(true)
            Hierarchy.Files = self.DownloadedFiles
            local IsValid = UVersionMgr.Get():IsValidHierarchy(Hierarchy)
            FLOG_INFO("[PreDownloadMgr:InitDownload] OnFinished IsValid:%s", tostring(IsValid))
            if IsValid then
                UVersionMgr.Get():AddHierarchy(Hierarchy)
                UVersionMgr.Get():SaveRecorderToDisk()
            end
        else
            --下载出错
            local Cnt = Results.ErrorUnits:Length()
            local ErrorCode = 0
            for i = 1, Cnt, 1 do
                local ErrorUnit = Results.ErrorUnits:Get(i)
                ErrorCode = ErrorUnit.Result.ErrorCode
                break
            end
            FLOG_INFO("[PreDownloadMgr:InitDownload] OnFinished - ErrorCode:%d", ErrorCode)

            DataReportUtil.ReportLoginFlowData(_G.UE.EDataReportLoginPhase.PreDownloadFailed)
            if not ErrorCode or ErrorCode == 0 then
                --没找到错误码，但还是下载出错的
                _G.MsgBoxUtil.ShowMsgBoxOneOpRight(nil, LSTR(LoginStrID.TipsTitle), LSTR(LoginStrID.DownloadErr))
                _G.UE.UGPMMgr.Get():PostLoginStepEvent(_G.UE.EDataReportLoginPhase.PreDownloadFailed, 1, 1, "failed", "", false, false)
            else
                --有错误码
                local Content = string.format(LSTR(LoginStrID.DownloadErrWithCode), ErrorCode)
                _G.MsgBoxUtil.ShowMsgBoxOneOpRight(nil, LSTR(LoginStrID.TipsTitle), Content)
                _G.UE.UGPMMgr.Get():PostLoginStepEvent(_G.UE.EDataReportLoginPhase.PreDownloadFailed, 1, ErrorCode, "failed", "", false, false)
            end

            self.PreDownloadState = LoginNewDefine.PreDownloadState.Error
            _G.UE.USaveMgr.SetInt(SaveKey.PreDownloadFlag, LoginNewDefine.PreDownloadState.Error, true)
            EventMgr:SendEvent(EventID.PreDownloadState, LoginNewDefine.PreDownloadState.Error)
        end
        --EventMgr:SendEvent(EventID.PreDownloadFinish, Results)
        self.OnFinishDelegateRef = nil
        self.OnProgressDelegateRef = nil
        self.OnUnitFinishedDelegateRef = nil
        self.DownloadFailed = true
    end
    local function OnUnitFinishedProgress(Delegate, Downloader, UnitRecord)
        if UnitRecord and UnitRecord.PufferUnit and UnitRecord.PufferUnit.Src then
            FLOG_INFO("[PreDownloadMgr:InitDownload] OnUnitFinishedProgress - Unit finish:%s", UnitRecord.PufferUnit.Src)
        end
    end

    --local OnFinishDelegate = CommonUtil.GetDelegatePair(OnFinished, false)
    --local OnProgressDelegate = CommonUtil.GetDelegatePair(OnPufferTaskProgress, false)
    --local OnUnitFinishedDelegate = CommonUtil.GetDelegatePair(OnUnitFinishedProgress, false)
    local OnFinishDelegateRef, OnFinishDelegate = self:GetDelegatePair(OnFinished)
    local OnProgressDelegateRef, OnProgressDelegate = self:GetDelegatePair(OnPufferTaskProgress)
    local OnUnitFinishedDelegateRef, OnUnitFinishedDelegate = self:GetDelegatePair(OnUnitFinishedProgress)
    self.OnFinishDelegateRef = OnFinishDelegateRef
    self.OnProgressDelegateRef = OnProgressDelegateRef
    self.OnUnitFinishedDelegateRef = OnUnitFinishedDelegateRef
    local CreateRet = _G.UE.UPufferMgr:Get():CreateDownloader(PufferTask, OnFinishDelegate, OnProgressDelegate, OnUnitFinishedDelegate)

    local InitStatus = CreateRet.InitStatus
    FLOG_INFO("[PreDownloadMgr:InitDownload] InitStatus:%d", InitStatus)
    if InitStatus == _G.UE.ELaunchPufferTaskStatus.DOWNLOADED then
        -- 3
        self.PreDownloadState = LoginNewDefine.PreDownloadState.Finish
        EventMgr:SendEvent(EventID.PreDownloadState, LoginNewDefine.PreDownloadState.Finish)

    elseif InitStatus == _G.UE.ELaunchPufferTaskStatus.INVALID then
        -- 2
        self.PreDownloadState = LoginNewDefine.PreDownloadState.Error
        _G.UE.USaveMgr.SetInt(SaveKey.PreDownloadFlag, LoginNewDefine.PreDownloadState.Error, true)
        EventMgr:SendEvent(EventID.PreDownloadState, LoginNewDefine.PreDownloadState.Error)
        _G.MsgBoxUtil.ShowMsgBoxOneOpRight(nil, LSTR(LoginStrID.TipsTitle), LSTR(LoginStrID.PufferStartErr))

    elseif InitStatus == _G.UE.ELaunchPufferTaskStatus.PUFFER_NOT_INIT then
        DataReportUtil.ReportLoginFlowData(_G.UE.EDataReportLoginPhase.PreDownloadFailed)
        _G.UE.UGPMMgr.Get():PostLoginStepEvent(_G.UE.EDataReportLoginPhase.PreDownloadFailed, 1, 2, "failed", "", false, false)
        -- 1
        self.PreDownloadState = LoginNewDefine.PreDownloadState.Error
        _G.UE.USaveMgr.SetInt(SaveKey.PreDownloadFlag, LoginNewDefine.PreDownloadState.Error, true)
        EventMgr:SendEvent(EventID.PreDownloadState, LoginNewDefine.PreDownloadState.Error)
        _G.MsgBoxUtil.ShowMsgBoxOneOpRight(nil, LSTR(LoginStrID.TipsTitle), LSTR(LoginStrID.PufferInitErr))

    elseif InitStatus == _G.UE.ELaunchPufferTaskStatus.SUCCESS then
        --DataReportUtil.ReportLoginFlowData(_G.UE.EDataReportLoginPhase.PreDownloadStart)
        -- 4
        --self.PreDownloadState = LoginNewDefine.PreDownloadState.Normal
        --EventMgr:SendEvent(EventID.PreDownloadState, LoginNewDefine.PreDownloadState.Normal)

        --local DownloadedSize = CreateRet.Downloader:GetDownloadedSize()
        local TotalSize = CreateRet.Downloader:GetTotalSizeCompressed()
        local DownloadedSize = TotalSize - CreateRet.Downloader:GetNeedDownloadSize()
        if DownloadedSize > 0 then
            local TempProgress = {}
            --TempProgress.nowSize = DownloadedSize
            --TempProgress.totalSize = DownloadedSize + CreateRet.Downloader:GetNeedDownloadSize()
            TempProgress.totalSize = TotalSize
            if TempProgress.totalSize < 0 then
                TempProgress.totalSize = 0
                FLOG_INFO("[PreDownloadMgr:InitDownload] totalSize: %d", TotalSize)
            end
            TempProgress.nowSize = DownloadedSize
            if TempProgress.nowSize < 0 then
                TempProgress.nowSize = 0
                FLOG_INFO("[PreDownloadMgr:InitDownload] nowSize invalid: %d/%d", TotalSize, CreateRet.Downloader:GetNeedDownloadSize())
            end
            self.DownloadProgress = TempProgress
            FLOG_INFO("[PreDownloadMgr:InitDownload] Progress %d/%d", TempProgress.nowSize, TempProgress.totalSize)

            self.PreDownloadState = LoginNewDefine.PreDownloadState.Pause
            EventMgr:SendEvent(EventID.PreDownloadState, LoginNewDefine.PreDownloadState.Pause)
        else
            self.PreDownloadState = LoginNewDefine.PreDownloadState.Normal
            EventMgr:SendEvent(EventID.PreDownloadState, LoginNewDefine.PreDownloadState.Normal)
        end
    end

    self.PufferDownloader = CreateRet.Downloader
    return CreateRet
end

function PreDownloadMgr:DownloadStart()
    if self.PufferDownloader and self.PufferDownloader:IsValid() then
        FLOG_INFO("[PreDownloadMgr:DownloadStart] DownloadStart")
        self.HasStartDownload = true

        self.PreDownloadState = LoginNewDefine.PreDownloadState.Downloading
        EventMgr:SendEvent(EventID.PreDownloadState, LoginNewDefine.PreDownloadState.Downloading)
        self.PufferDownloader:TryDownloadTask()

        DataReportUtil.ReportLoginFlowData(_G.UE.EDataReportLoginPhase.PreDownloadStart)
        _G.UE.UGPMMgr.Get():PostLoginStepEvent(_G.UE.EDataReportLoginPhase.PreDownloadStart, 0, 0, "success", "", false, false)
    else
        FLOG_WARNING("[PreDownloadMgr:DownloadStart] PufferDownloader is invalid")
    end
end

function PreDownloadMgr:DownloadPause()
    if self.PufferDownloader and self.PufferDownloader:IsValid() then
        FLOG_INFO("[PreDownloadMgr:DownloadPause] Pause")

        -- TODO 空间判断


        self.PreDownloadState = LoginNewDefine.PreDownloadState.Pause
        EventMgr:SendEvent(EventID.PreDownloadState, LoginNewDefine.PreDownloadState.Pause)
        self.PufferDownloader:Pause()
    else
        FLOG_WARNING("[PreDownloadMgr:DownloadPause] PufferDownloader is invalid")
    end
end

function PreDownloadMgr:DownloadResume()
    if self.DownloadFailed then
        FLOG_INFO("[PreDownloadMgr:DownloadResume] CreateDownloader and retry... ")
        self.DownloadFailed = false;
        self.HasStartDownload = false;

        self.OnFinishDelegateRef = nil
        self.OnProgressDelegateRef = nil
        self.OnUnitFinishedDelegateRef = nil
        self.CreateRet = nil
        self.PufferDownloader = nil
        self:InitDownload()
        self:DownloadStart()
        return
    end

    if not self.HasStartDownload then
        self:DownloadStart()
        return
    end

    if self.PufferDownloader and self.PufferDownloader:IsValid() then
        self.PreDownloadState = LoginNewDefine.PreDownloadState.Downloading
        EventMgr:SendEvent(EventID.PreDownloadState, LoginNewDefine.PreDownloadState.Downloading)

        FLOG_INFO("[PreDownloadMgr:DownloadResume] Resume")
        self.PufferDownloader:Resume()
    else
        FLOG_WARNING("[PreDownloadMgr:DownloadResume] PufferDownloader is invalid")
    end
end

function PreDownloadMgr:GetDelegatePair(InFunc)
    if type(InFunc) ~= "function" then
        return nil
    end

    local Proxy = NewObject(ULuaDelegateProxy)
    local Ref = UnLuaRef(Proxy)

    local WrappedFunc = function(...)
        InFunc(...)
    end
    return Ref, { Proxy, WrappedFunc }
end

return PreDownloadMgr
---
--- Generated by Luanalysis
--- Created by skysong.
--- DateTime: 2022/12/14 14:09
---

local LuaClass = require("Core/LuaClass")
local MgrBase = require("Common/MgrBase")
local ProtoCS = require("Protocol/ProtoCS")
local ChallengeLogCfg = require("TableCfg/ChallengeLogCfg")
local EventMgr = require("Event/EventMgr")
local EventID = require("Define/EventID")
local LootMappingCfg = require("TableCfg/LootMappingCfg")
local ItemUtil = require("Utils/ItemUtil")
local ChallengeLogRewardCfg = require("TableCfg/ChallengeLogRewardCfg")
local UIViewMgr = require("UI/UIViewMgr")
local UIViewID = require("Define/UIViewID")
local SaveKey = require("Define/SaveKey")
local Json = require("Core/Json")
local TimeUtil = require("Utils/TimeUtil")
local GlobalCfg = require("TableCfg/GlobalCfg")
local ProtoRes = require("Protocol/ProtoRes")
local LootCfg = require("TableCfg/LootCfg")
local LevelExpCfg = require("TableCfg/LevelExpCfg")
local MajorUtil = require("Utils/MajorUtil")
local ClientGlobalCfg = require("TableCfg/ClientGlobalCfg")
local AdventureDefine = require("Game/Adventure/AdventureDefine")
local CompanySealMgr = require("Game/CompanySeal/CompanySealMgr")
local ProtoCommon = require("Protocol/ProtoCommon")
local RedDotMgr = require("Game/CommonRedDot/RedDotMgr")
local ModuleOpenMgr
local PWorldEntPolDR = require("Game/PWorld/Entrance/Policy/PWorldEntPolDR")

local USaveMgr = _G.UE.USaveMgr
local COUNTER_CMD = ProtoCS.CS_COUNTER_CMD
local CS_CMD = ProtoCS.CS_CMD
local CS_ADVENTURE_CMD = ProtoCS.CS_ADVENTURE_CMD
local GameNetworkMgr
local DailyRefreshOffset 
local WeeklyRefreshOffset
local DailyRawardCfg = {}         --- 每日随机奖励配置
local SceneEnterCfg = {}
local StageRewardID = 0

-- @class AdventureMgr : MgrBase
local AdventureMgr = LuaClass(MgrBase)

function AdventureMgr:Ctor()
    self.ChallengeLogs = {}
    self.FinishCount = 0
    self.RewardNum = 0
    self.CollectRewards = {}
    self.MaxFinishCount = nil
    self.RecommendTask = {}
    self.ChallengeLogCfg = {}
    self.AutoGetRewardReq = {}
end

local function SetStageRewardID()
    local TableData = ClientGlobalCfg:FindCfgByKey(ProtoRes.client_global_cfg_id.GLOBAL_CFG_ADVENTURE_REWARD_STAGE)
    if TableData then
        StageRewardID = TableData.Value and TableData.Value[1] or 0
    end
end

function AdventureMgr:OnBegin()
    GameNetworkMgr = _G.GameNetworkMgr
    ModuleOpenMgr = _G.ModuleOpenMgr
    local WeeklyValue = GlobalCfg:FindValue(ProtoRes.global_cfg_id.GLOBAL_CFG_CHALLENGELOG_REFRESH_HOUR_OFFSET, "Value")
    WeeklyRefreshOffset = WeeklyValue and WeeklyValue[1] or 8

    local DailyValue = GlobalCfg:FindValue(ProtoRes.global_cfg_id.GLOBAL_CFG_SCENE_DAILYRANDOM_REFRESH_HOUR_OFFSET, "Value")
    DailyRefreshOffset = DailyValue and DailyValue[1] or 5

    SetStageRewardID()
    self:InitConfig()
end

function AdventureMgr:InitConfig()
    for _,ChallengeLog in pairs(ChallengeLogCfg:FindAllCfg()) do
        self.ChallengeLogCfg[ChallengeLog.LogID] = ChallengeLog
    end

    local total = 0
    local Cfgs = ChallengeLogRewardCfg:FindAllCfg()
    if Cfgs then
        for _,V in pairs(Cfgs) do
            if V.Count and V.Count > total then
                total = V.Count
            end
        end
    end

    self.MaxFinishCount = total
    local SceneDailyRandomRewardCfg = require("TableCfg/SceneDailyRandomRewardCfg")
    local DailyRandomRewardCfgs = SceneDailyRandomRewardCfg:FindAllCfg()
    if DailyRandomRewardCfgs then
        for k, v in pairs(DailyRandomRewardCfgs) do
            if not DailyRawardCfg[v.Level] then
                DailyRawardCfg[v.Level] = {}
            end

            table.insert(DailyRawardCfg[v.Level], v)
        end
    end

    local SceneEnterDailyRandomCfg = require("TableCfg/SceneEnterDailyRandomCfg")
    local SceneEnterCfgs = SceneEnterDailyRandomCfg:FindAllCfg()
    if SceneEnterCfgs then
        for _, Cfg in pairs(SceneEnterCfgs) do
            table.insert(SceneEnterCfg, Cfg)
        end
    end
end

function AdventureMgr:OnEnd()
end

function AdventureMgr:OnShutDown()
    self.ChallengeLogCfg = {}
end

function AdventureMgr:OnRegisterNetMsg()
    self:RegisterGameNetMsg(CS_CMD.CS_CMD_ADVENTURE, CS_ADVENTURE_CMD.CS_ADVENTURE_CMD_CHALLENGE_LOG, self.OnNetMsgChallengeLog)
    self:RegisterGameNetMsg(CS_CMD.CS_CMD_ADVENTURE, CS_ADVENTURE_CMD.CS_ADVENTURE_CMD_CHALLENGE_LOG_REWARD, self.OnNetMsgChallengeLogReward)
    self:RegisterGameNetMsg(CS_CMD.CS_CMD_ADVENTURE, CS_ADVENTURE_CMD.CS_ADVENTURE_CMD_CHALLENGE_LOG_COLLECT, self.OnNetMsgChallengeLogCollect)
    self:RegisterGameNetMsg(CS_CMD.CS_CMD_ADVENTURE, CS_ADVENTURE_CMD.CS_ADVENTURE_CMD_CHALLENGE_LOG_REWARD_COLLECT, self.OnNetMsgChallengeLogRewardCollect)
    self:RegisterGameNetMsg(CS_CMD.CS_CMD_COUNTER, COUNTER_CMD.UPDATE_NOTIFY, self.OnNetMsgCounterUpdateNotify)
    self:RegisterGameNetMsg(CS_CMD.CS_CMD_LOOT, 0, self.OnNetMsgLoot)
    self:RegisterGameEvent(EventID.ModuleOpenNotify, self.OnModuleOpenNotify)
    self:RegisterGameEvent(EventID.UpdateQuest, self.OnUpdateQuest)
end

function AdventureMgr:OnModuleOpenNotify(ModuleID)
	if ModuleID == ProtoCommon.ModuleID.ModuleIDDailyRand then
        RedDotMgr:AddRedDotByID(AdventureDefine.RedDefines.DailyUnLockRed)
	elseif ModuleID == ProtoCommon.ModuleID.ModuleIDChallengeNote then
        RedDotMgr:AddRedDotByID(AdventureDefine.RedDefines.WeekUnLockRed)
    end
end

function AdventureMgr:OnUpdateQuest()
    --- 日随 随着副本前置任务解锁新增并显示红点
    self:RegisterTimer(function()
        if not ModuleOpenMgr:CheckOpenState(ProtoCommon.ModuleIDDailyRand) then return end
        local AdventureRedData = self:GetAdventureTaskSaveData()
        local RecordTask = string.split(AdventureRedData.DailyTaskRecord or "", ",")
        local DailyTaskData = self:GetSceneEnterDailyTask()
        if #RecordTask < #DailyTaskData then
            local DailyRandomNewRedData = AdventureDefine.TabNewRed[AdventureDefine.MainTabIndex.Daily]
            RedDotMgr:AddRedDotByID(DailyRandomNewRedData.Child)
        end
    end, 1, 0, 1)
end

function AdventureMgr:OnRegisterGameEvent()
    self:RegisterGameEvent(EventID.RoleLoginRes, self.OnGameEventLoginRes)
end

function AdventureMgr:JumpAndScrollToTargetWeekTask(TargetLogID)
    if not ModuleOpenMgr:ModuleState(ProtoCommon.ModuleID.ModuleIDChallengeNote) then
        return
    end

    local Params = {
        JumpData = {
            [1] = AdventureDefine.MainTabIndex.Weekly,
            [2] = TargetLogID,
        }
	}
    
	UIViewMgr:ShowView(UIViewID.AdventruePanel, Params)
end

function AdventureMgr:OnGameEventLoginRes()
    if not ModuleOpenMgr:CheckOpenState(ProtoCommon.ModuleID.ModuleIDChallengeNote) then
        return
    end

    self:SendChallengeLog(0)
    self:SendChallengelogReward()
end

function AdventureMgr:GetChallengeOriginLogs()
    return self.ChallengeLogs
end

function AdventureMgr:GetChallengeLogs()
    local ChallengeLogs = {}
    local SupplyType = ProtoRes.challenge_log_type.CHALLENGE_LOG_TYPE_SUPPLY
    local CompoanySealInfo = CompanySealMgr:GetCompanySealInfo()
    local GrandCompanyID = CompoanySealInfo.GrandCompanyID
    for i, v in pairs(self.ChallengeLogs) do
        local IsOpen = not v.ModuleID or v.ModuleID == 0 or (v.ModuleID and ModuleOpenMgr:CheckOpenState(v.ModuleID))
        local IsPwordOpen =  not v.PWorldID or v.PWorldID == 0 or (v.PWorldID and ModuleOpenMgr:CheckOpenState(v.PWorldID))

        if IsOpen and IsPwordOpen then
            if v.Type == SupplyType then
                if GrandCompanyID ~= 0  then
                    table.insert(ChallengeLogs, v)
                end
            else
                table.insert(ChallengeLogs, v)
            end
        end
    end

    return ChallengeLogs
end

--- 获取特定分类的挑战笔记
---@param Category ProtoRes.challenge_log_category@特定分类
function AdventureMgr:GetCategoryChallengeLogs(Category)
    local ChallengeLogs = {}
    local SupplyType = ProtoRes.challenge_log_type.CHALLENGE_LOG_TYPE_SUPPLY
    local CompoanySealInfo = CompanySealMgr:GetCompanySealInfo()
    local GrandCompanyID = CompoanySealInfo.GrandCompanyID
    for _, v in pairs(self.ChallengeLogs) do
        if not v.ModuleID or v.ModuleID == 0 or (v.ModuleID and ModuleOpenMgr:CheckOpenState(v.ModuleID)) then
            if Category == v.Category then
                if v.Type == SupplyType then
                    if GrandCompanyID ~= 0  then
                        table.insert(ChallengeLogs, v)
                    end
                else
                    table.insert(ChallengeLogs, v)
                end
            end
        end
    end

    return ChallengeLogs
end

function AdventureMgr:GetChallengeLogCollect()
    return self.CollectRewards
end

---是否领取过宝箱奖励
---@param Count number
---@return boolean
function AdventureMgr:IsRewardCollected(Count)
    for _,V in pairs(self.CollectRewards) do
        if V == Count then
            return true
        end
    end
    return false
end

---获取当前完成数
---@return number
function AdventureMgr:GetFinishCount()
    return self.FinishCount
end

---获取最大完成数
---@return number
function AdventureMgr:GetMaxFinishCount()
    if not self.MaxFinishCount then
        local total = 0
        local Cfgs = ChallengeLogRewardCfg:FindAllCfg()
        if Cfgs then
            for _,V in pairs(Cfgs) do
                if V.Count and V.Count > total then
                    total = V.Count
                end
            end
        end
        self.MaxFinishCount = total
    end
    return self.MaxFinishCount
end

function AdventureMgr:GetChallengeCategoryCount(Category)
    local Count = 0

    for _,Value in pairs(self.ChallengeLogs) do
        if Value.Category == Category then
            Count = Count + 1
        end
    end

    return Count
end

--- 挑战笔记的回包,收到挑战笔记状态
---@param MsgBody any
function AdventureMgr:OnNetMsgChallengeLog(MsgBody)
    self.FinishCount = 0
    for _,ChallengeLog in ipairs(MsgBody.ChallengeLog.ChallengeLogs) do
        local Cfg = self.ChallengeLogCfg[ChallengeLog.LogID]

        if Cfg ~= nil then
            ChallengeLog.Category = Cfg.Category
           -- ChallengeLog.LootIDs = Cfg.Produce
            ChallengeLog.Desc = Cfg.Desc
            ChallengeLog.Total = Cfg.Count
            ChallengeLog.RewardItemList = self:GetLootItems(Cfg.LootID)
            ChallengeLog.Type = Cfg.Type
            ChallengeLog.Icon = Cfg.Icon
            ChallengeLog.JumpID = Cfg.JumpID or 0
            ChallengeLog.ModuleID = Cfg.ModuleID
            ChallengeLog.FinishMsg = Cfg.FinishMsg
            ChallengeLog.PWorldID = Cfg.PWorldID
            if ChallengeLog.Progress >= Cfg.Count then
                if ChallengeLog.Collected then
                    ChallengeLog.IsFinish = false
                else
                    ChallengeLog.IsFinish = true
                end
                self.FinishCount = self.FinishCount + 1
            else
                ChallengeLog.IsFinish = false
            end

            self.ChallengeLogs[ChallengeLog.LogID] = ChallengeLog
        end
    end

    EventMgr:SendEvent(EventID.GetChallengeLogInfo)
    self:AutoGetWeeklyReward()
    self:UpdateStageRewardRed()
end

--- 挑战笔记的回包,收到挑战笔记宝箱状态
---@param MsgBody any
function AdventureMgr:OnNetMsgChallengeLogReward(MsgBody)
    self.RewardNum = MsgBody.ChallengeLogReward.FinishCount
    self.CollectRewards = {}

    for _,CollectReward in ipairs(MsgBody.ChallengeLogReward.CollectedRewards) do
        table.insert(self.CollectRewards, CollectReward.Num)
    end

    EventMgr:SendEvent(EventID.GetChallengeRewardCollect)
    self:UpdateStageRewardRed()
end

--- 挑战笔记的回包,领取挑战笔记奖励(周任务奖励)
---@param MsgBody any
function AdventureMgr:OnNetMsgChallengeLogCollect(MsgBody)
    if not MsgBody then
        return
    end

    local ChallengeLogCollect = MsgBody.ChallengeLogCollect
    if not ChallengeLogCollect then
        return
    end

    local LogID = ChallengeLogCollect.LogID or 0
    for _, ChallengeLog in pairs(self.ChallengeLogs) do
        if ChallengeLog.LogID == LogID then
            ChallengeLog.Collected = true
            if ChallengeLog.FinishMsg then
                local MsgTipsID = require("Define/MsgTipsID")
                _G.MsgTipsUtil.ShowTipsByID(MsgTipsID.WeekTaskRewardTips, nil, ChallengeLog.FinishMsg)
            end
            break
        end
    end

    EventMgr:SendEvent(EventID.GetChallengeLogCollect, LogID)
    self:UpdateStageRewardRed()
end

--- 挑战笔记的回包,领取挑战笔记宝箱奖励
---@param MsgBody any
function AdventureMgr:OnNetMsgChallengeLogRewardCollect(MsgBody)
    table.insert(self.CollectRewards, MsgBody.ChallengeLogRewardCollect.Num)
    EventMgr:SendEvent(EventID.GetChallengeLogRewardCollect)
    self:UpdateStageRewardRed()
end

function AdventureMgr:OnNetMsgLoot(MsgBody)
    if MsgBody and MsgBody.Reason and  MsgBody.Reason == "role.challenge.LogReward" then
        local LOOT_TYPE = ProtoCS.LOOT_TYPE
        local ItemList = {}
        for k, v in pairs(MsgBody.LootList) do
            if v.Type == LOOT_TYPE.LOOT_TYPE_ITEM then 
                table.insert(ItemList, {ResID = v.Item.ResID, Num = v.Item.Value})
            elseif v.Type == LOOT_TYPE.LOOT_TYPE_SCORE then 
                table.insert(ItemList, {ResID = v.Score.ResID, Num = v.Score.Value})
            end
        end
    
        if next(ItemList) then
            UIViewMgr:ShowView(UIViewID.CommonRewardPanel, {ItemList = ItemList})
        end
    end
end

--- 请求挑战笔记状态
---@param FilterCatagory number
function AdventureMgr:SendChallengeLog(FilterCatagory)
    local MsgID = CS_CMD.CS_CMD_ADVENTURE
    local SubMsgID = CS_ADVENTURE_CMD.CS_ADVENTURE_CMD_CHALLENGE_LOG

    local MsgBody = {
        Cmd = SubMsgID,
        ChallengeLog = {
            FilterCategory = FilterCatagory
        }
    }

    GameNetworkMgr:SendMsg(MsgID, SubMsgID, MsgBody)
end

--- 获取挑战笔记宝箱状态
function AdventureMgr:SendChallengelogReward()
    local MsgID = CS_CMD.CS_CMD_ADVENTURE
    local SubMsgID = CS_ADVENTURE_CMD.CS_ADVENTURE_CMD_CHALLENGE_LOG_REWARD

    local MsgBody = {
        Cmd = SubMsgID,
        ChallengeRewardLog = {}
    }

    GameNetworkMgr:SendMsg(MsgID, SubMsgID, MsgBody)
end

--- 领取挑战笔记奖励
---@param LogID number
function AdventureMgr:SendChallengelogCollect(LogID)
    local ServerTime = TimeUtil.GetServerTime()
    local NeedAutoGet = false
    if not self.AutoGetRewardReq[LogID] then
        self.AutoGetRewardReq[LogID] = ServerTime
        NeedAutoGet = true
    else
        if ServerTime - self.AutoGetRewardReq[LogID] > 10 then
            NeedAutoGet = true
        end
    end

    if NeedAutoGet then
        local MsgID = CS_CMD.CS_CMD_ADVENTURE
        local SubMsgID = CS_ADVENTURE_CMD.CS_ADVENTURE_CMD_CHALLENGE_LOG_COLLECT
        local MsgBody = {
            Cmd = SubMsgID,
            ChallengeLogCollect = {
                LogID = LogID
            }
        }
        GameNetworkMgr:SendMsg(MsgID, SubMsgID, MsgBody)
    end
end

--- 领取挑战笔记宝箱奖励
---@param Count number
function AdventureMgr:SendChallengeLogRewardCollect(Count)
    local MsgID = CS_CMD.CS_CMD_ADVENTURE
    local SubMsgID = CS_ADVENTURE_CMD.CS_ADVENTURE_CMD_CHALLENGE_LOG_REWARD_COLLECT

    local MsgBody = {
        Cmd = SubMsgID,
        ChallengeLogRewardCollect = {
            Num = Count
        }
    }

    _G.LootMgr:SetDealyState(true)
    GameNetworkMgr:SendMsg(MsgID, SubMsgID, MsgBody)
end

function AdventureMgr:OnNetMsgCounterUpdateNotify(MsgBody)
    if not ModuleOpenMgr:CheckOpenState(ProtoCommon.ModuleID.ModuleIDChallengeNote) then
        return
    end

    if StageRewardID == 0 then
        SetStageRewardID()
    end

	if MsgBody.Update.Counters and MsgBody.Update.Counters[StageRewardID] then
        self:SendChallengeLog(0)
        self:SendChallengelogReward()
    end
end

function AdventureMgr:GetLootItems(LootMapID)
    if not LootMapID then
        return nil
    end

    local CompoanySealInfo = CompanySealMgr:GetCompanySealInfo()
    local GrandCompanyID = CompoanySealInfo.GrandCompanyID
    local RewardCfg = {}
	local LootMappingData = LootMappingCfg:FindAllCfg(string.format("ID=%d", LootMapID))
    for i, v in ipairs(LootMappingData) do
        local Condition = v.Conditions or v._Conditions
        local GrandCompanyConds = Condition.GrandCompanyConds and Condition.GrandCompanyConds[1] or 0
        local Programs = v.Programs or v._Programs
        if GrandCompanyConds == 0 or GrandCompanyConds == GrandCompanyID then
            local LootID = Programs and Programs[1].ID or 0
            local LootCfgItem = LootCfg:FindCfgByKey(LootID)
            if not LootCfgItem or not next(LootCfgItem) then return nil end
            local LootRewardCfg = ItemUtil.GetLootItems(LootID)
            for i, v in ipairs(LootRewardCfg) do
                table.insert(RewardCfg, v)
            end

            local LevelCfg = LevelExpCfg:FindCfgByKey(MajorUtil.GetMajorLevel())
            if LootCfgItem.ExpRatio and LootCfgItem.ExpRatio ~= 0 and LevelCfg then
                table.insert(RewardCfg, {
                    ResID = ProtoRes.SCORE_TYPE.SCORE_TYPE_UPGRADE_EXP, -- 升级经验
                    Num = math.ceil(LootCfgItem.ExpRatio / 10000 * LevelCfg.NextExp),
                })
            end
        end
    end

    return RewardCfg
end

function AdventureMgr:GetDailyRewardCfgByLevelType(TypeID, Level)
    if not next(DailyRawardCfg) then return {} end

    if DailyRawardCfg[Level] then
        for i, v in ipairs(DailyRawardCfg[Level]) do
            if TypeID == v.Type then
                return v
            end
        end
    end
end

function AdventureMgr:GetSceneEnterDailyRandomData()
    return SceneEnterCfg
end

function AdventureMgr:GetWeeklyRefreshSurplusTime()
    local ServerTime = TimeUtil.GetServerLogicTime()
    local MondayZero = TimeUtil.GetMondayZero(ServerTime)
    local OffTimeHour = (os.time() - os.time(os.date("!*t"))) / 3600

    local NextTimeSpan = WeeklyRefreshOffset * 3600 + MondayZero - (8 - OffTimeHour) * 3600
    if NextTimeSpan < ServerTime  then
        NextTimeSpan = NextTimeSpan + 604800
    end

    return NextTimeSpan - ServerTime, NextTimeSpan
end

function AdventureMgr:GetDailyRefreshSurplusTime()
    local ServerTime = TimeUtil.GetServerTime()
    local CurDayZeroTime = TimeUtil.GetCurTimeStampZero(ServerTime)
    local OffTimeHour = (os.time() - os.time(os.date("!*t"))) / 3600

    local NextTimeSpan = DailyRefreshOffset * 3600 + CurDayZeroTime - (8 - OffTimeHour) * 3600
    if NextTimeSpan < ServerTime  then
        NextTimeSpan = NextTimeSpan + 86400
    end

    return NextTimeSpan - ServerTime, NextTimeSpan
end

function AdventureMgr:GetSurplusTimeAndNextSpanTime(PageIndex)
    if PageIndex == AdventureDefine.MainTabIndex.Daily then
        return self:GetDailyRefreshSurplusTime()
    elseif PageIndex == AdventureDefine.MainTabIndex.Weekly then
        return self:GetWeeklyRefreshSurplusTime()
    else
        FLOG_INFO("AdventureMgr:GetSurplusTimeAndNextSpanTime, Error PageIndex")
    end
end

function AdventureMgr:GetAdventureTaskSaveData()
    local JsonStr = USaveMgr.GetString(SaveKey.AdventureReadTime, "", true)
    local AdventureTaskReadTimeData = string.isnilorempty(JsonStr) and {} or Json.decode(JsonStr)
    return AdventureTaskReadTimeData
end

function AdventureMgr:SetAdventureReadTimeByIndex(PageIndex)
    if PageIndex then
        local AdventureRedData = self:GetAdventureTaskSaveData()
        local _, NextRefreshTime = self:GetSurplusTimeAndNextSpanTime(PageIndex)
        if PageIndex == AdventureDefine.MainTabIndex.Daily then
            AdventureRedData.DailyReadTime = NextRefreshTime
        else
            AdventureRedData.WeeklyReadTime = NextRefreshTime
        end

        local SaveJsonStr = Json.encode(AdventureRedData)
        USaveMgr.SetString(SaveKey.AdventureReadTime, SaveJsonStr, true)
    end
end

function AdventureMgr:SaveDailyTaskNum()
    local AdventureRedData = self:GetAdventureTaskSaveData()
    if not AdventureRedData.DailyTaskRecord then
        AdventureRedData.DailyTaskRecord = ""
    end

    local DailyTaskData = self:GetSceneEnterDailyTask()
    local RedStr = ""
    for i, v in ipairs(DailyTaskData) do
        RedStr = RedStr == "" and tostring(v.ID) or string.format("%s,%d", RedStr, v.ID)
    end

    AdventureRedData.DailyTaskRecord = RedStr
    local SaveJsonStr = Json.encode(AdventureRedData)
    USaveMgr.SetString(SaveKey.AdventureReadTime, SaveJsonStr, true)
end

---- 当前页签是否未进入过(日随每天刷 周任务每周刷)
function AdventureMgr:IsCurTabNotRead(PageIndex)
    local AdventureRedData = self:GetAdventureTaskSaveData()
    local SaveReadData = AdventureRedData.ReadTime or {}
    local _, NextRefreshTime = self:GetSurplusTimeAndNextSpanTime(PageIndex)
    if PageIndex and AdventureDefine.TabNewRed[PageIndex] then
        if PageIndex == AdventureDefine.MainTabIndex.Daily then
            return not (tonumber(AdventureRedData.DailyReadTime or 0) == NextRefreshTime)
        elseif PageIndex == AdventureDefine.MainTabIndex.Weekly then
            return not (tonumber(AdventureRedData.WeeklyReadTime or 0) == NextRefreshTime)
        else
            return false
        end
    end

    return false
end

function AdventureMgr:IsStageRewardCanGet()
    if not ModuleOpenMgr:CheckOpenState(ProtoCommon.ModuleID.ModuleIDChallengeNote) then return false end

    local RewardCfgs = ChallengeLogRewardCfg:FindAllCfg()
    local FinishCount = AdventureMgr:GetFinishCount() or 0
    if RewardCfgs then
        for _,V in ipairs(RewardCfgs) do
            if V and V.Count then
                if FinishCount >= V.Count then
                    if not AdventureMgr:IsRewardCollected(V.Count) then
                        return true
                    end
                end
            end
        end
    end

    return false
end

function AdventureMgr:AutoGetWeeklyReward()
    local ChallengeLog = self:GetChallengeOriginLogs()
    local GetRewardData = {}
    for i, v in pairs(ChallengeLog) do
        if v.IsFinish and not v.Collected then
            table.insert(GetRewardData, i)
        end
    end

    if next(GetRewardData) then
        local RewardPos = 1
        self:RegisterTimer(function()
            self:SendChallengelogCollect(GetRewardData[RewardPos])
            RewardPos = RewardPos + 1
        end, 0, 1, #GetRewardData)
    end
end

function AdventureMgr:UpdateStageRewardRed()
    if self:IsStageRewardCanGet() then
        RedDotMgr:AddRedDotByID(AdventureDefine.RedDefines.WeekTaskStage)
    else
        RedDotMgr:DelRedDotByID(AdventureDefine.RedDefines.WeekTaskStage)
    end
end

--- 角色中最大的等级
function AdventureMgr:GetMaxRoleLevel()
    local MajorRoleDetail = MajorUtil.GetMajorRoleDetail() or {}
    local Prof = MajorRoleDetail.Prof or {}
    local MaxRoleLevel = 1
    if Prof.ProfList and next(Prof.ProfList) then
        for i, v in pairs(Prof.ProfList) do
            if v.Level > MaxRoleLevel then
                MaxRoleLevel = v.Level
            end
        end
    end

    return MaxRoleLevel
end

--- 每日随机任务数据
function AdventureMgr:GetSceneEnterDailyTask()
    local Cfgs = AdventureMgr:GetSceneEnterDailyRandomData()
    if not Cfgs then return {} end

    local MaxRoleLevel = self:GetMaxRoleLevel()
    local IsBattleMentor = _G.OnlineStatusMgr:MajorHasIdentity(ProtoRes.OnlineStatusIdentify.OnlineStatusIdentifyBattleMentor)
    local DailyTaskData = {}
    for _, Cfg in pairs(Cfgs) do
        --按条件判断是否显示
        local CanShow = true
        --如果是随导类型的任务
        if Cfg.TaskType == ProtoRes.DailyRandomTaskType.DailyRandomTaskGuide then
            --判断玩家是否是战斗指导者
            CanShow = IsBattleMentor
        end

        CanShow = CanShow and PWorldEntPolDR:CheckFilter(Cfg.ID)
        if MaxRoleLevel >= Cfg.PlayerLv and CanShow then
            table.insert(DailyTaskData, Cfg)
        end
    end

    return DailyTaskData
end

--- 冒险周任务跳转军需 根据不同军队ID
function AdventureMgr:JumpSupplyByGrandCompanyID()
    local MapID = {
        [1] = 13001,
        [2] = 11001,
        [3] = 6020,
    }

    local CompanySealMgr = require("Game/CompanySeal/CompanySealMgr")
    local CompoanySealInfo = CompanySealMgr:GetCompanySealInfo()
    local GrandCompanyID = CompoanySealInfo.GrandCompanyID
    _G.WorldMapMgr:ShowWorldMap(MapID[GrandCompanyID])
end

return AdventureMgr